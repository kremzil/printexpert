# ARCHITECTURE_B2B_B2C.md
Дата: 2026-01-23  
Проект: Printexpert Next  
Цель: фундаментальное (архитектурное) разделение B2C/B2B без дублирования каталога и без SEO-дублей.

---

## 1 Принцип
B2C и B2B — это **не два сайта** и не два набора товаров.

Это один каталог и один расчёт цены, поверх которых накладывается **контекст аудитории (AudienceContext)**:
- влияет на отображение (net/gross, тексты, CTA),
- может влиять на коммерческие правила (скидки/условия),
- не меняет URL и структуру данных каталога.

---

## 2 AudienceContext (единый объект контекста)
В любой точке витрины/API должен существовать один вычисленный контекст:

- `audience`: `b2c | b2b`
- `source`: `query | cookie | account | default`
- `expiresAt` (для cookie; опционально)
- (опционально) `locale/country` для будущих налоговых правил

Контекст должен вычисляться одинаково на сервере и использоваться всеми слоями: рендер, API, действия.

---

## 3 Правила определения режима (приоритеты)
Должен быть один и тот же детерминированный порядок:

1) Query-параметр `?mode=b2b|b2c`  
   - используется для рекламы и прямых ссылок
2) Account preference (если есть авторизация)  
   - будущий режим: запомнить выбор навсегда
3) Cookie `audience=b2b|b2c`  
   - хранит выбор между визитами (например, 30 дней)
4) Default `b2c`

**Правило:** `query` всегда побеждает `cookie`.

---

## 4 Хранение состояния режима
### Клиент
- хранить выбор в **cookie**, не в localStorage:
  - сервер сможет сразу отрендерить корректный режим (SSR/RSC)
- cookie может быть обычной (не httpOnly) на MVP

### Сервер
- сервер должен уметь восстановить контекст по:
  - query
  - cookie
  - session/account (в будущем)

---

## 5 URL и SEO
### Принцип
- URL товара всегда один: `/product/[slug]`
- `?mode=` — **только** механизм входа/персонализации

### SEO-правила
- canonical указывает на URL без `mode`
- `mode` не должен создавать индексируемые дубликаты страниц
- режим аудитории трактуется как персонализация, а не отдельный контент-документ

---

## 6 Данные каталога и зависимость от режима
### Что НЕ зависит от режима
- Category / Product / ProductImage
- WP-матрицы и их структура (пока вы используете WP-таблицы)
- базовая логика расчёта (например, подбор цены по breakpoints и комбинациям)

### Что МОЖЕТ зависеть от режима (политики)
- presentation rules (что показываем как главное: net/gross)
- коммерческие правила (скидки, условия, доступные CTA)
- lead/order flow (B2B может предлагать запрос предложения)

---

## 7 Pricing: один расчёт, разные представления
### Контракт результата расчёта цены
Любой расчёт должен возвращать структуру:

- `net`
- `vatAmount`
- `gross`
- `currency`
- (опционально) `breakdown` (что повлияло на цену)

### Ключевые правила
- расчёт цены должен быть **единым**, а не “двумя отдельными калькуляторами”
- `audience` влияет на:
  - что показываем как основную цену
  - какие политики скидок применяем (если есть)
- истина цены для лидов/заказов — **на сервере**
  - клиентская цена допустима только как предварительный показ
- серверный сервис `calculate(productId, params, audienceContext)` — единый источник истины
- API `/api/price` пересчитывает цену на сервере и возвращает `PriceResult`

---

## 8 Сервер — источник истины (важно для будущих заказов)
Любые операции, которые имеют значение для бизнеса, должны считаться на сервере:

- `lead/quote request`
- `order create`
- `payment/checkout`
- пересчёт при изменении параметров (при необходимости)

Сервер никогда не должен доверять “price” из клиента.

Дополнительно:
- клиентские операции показывают лишь предварительный расчёт
- финальный расчёт перед заказом обязателен через сервер

---

## 9 Аналитика и атрибуция
Во все ключевые события витрины добавлять:
- `audience` (`b2b|b2c`)
- `source` (`query|cookie|account|default`)

События минимум:
- `view_item`
- `add_to_cart`
- `begin_checkout`
- `lead_submit`
- `purchase`

Иначе невозможно оптимизировать рекламу и понять поведение сегментов.

---

## 10 Границы ответственности (слои)
Чтобы логика не расползалась, придерживаться слоёв:

1) **Audience Resolver (server-only)**
- вычисляет `AudienceContext` из request (query/cookie/session)

2) **Pricing Service (server-only)**
- `calculate(productId, params, audienceContext) -> PriceResult`
- поддерживает внутренние матрицы `PricingModel/PricingEntry` и WP-матрицы

3) **UI слой**
- получает `audience` и `priceResult` и лишь отображает
- для кнопок заказа запрашивает серверную цену

4) **Mutation endpoints**
- любые операции изменения состояния (lead/order/payment) пересчитывают цену на сервере

---

## 11 Расширение в будущем (без переделки основы)
Если появится:
- B2B компании и роли
- VAT ID / reverse charge
- персональные/накопительные скидки

Расширяется через дополнительные контексты и политики:
- `AccountContext` (user/company)
- `PricingPolicy` (скидки)
- `TaxPolicy` (налоги)

Но базовый `AudienceContext` остаётся неизменным.

---

## 12 Чеклист корректной реализации (MVP)
- [x] есть единый Audience Resolver с приоритетами query > account > cookie > default
- [x] режим хранится в cookie, сервер может определить его без клиента
- [x] canonical на товар/каталог не включает `mode`
- [x] price API считает цену на сервере и возвращает net/vat/gross (`/api/price`)
- [x] lead/order считают цену на сервере и возвращают net/vat/gross (`lib/orders.ts`)
- [ ] аналитика пишет `audience` и `source` во все ключевые события

---
